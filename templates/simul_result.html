<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="/static/app.css">
  <meta charset="UTF-8">
  <title>Alpha Cuda Simul — Detail</title>
  <style>
    /* === 통일된 스타일 (paramset/simul_list와 동일 톤) === */
    body { font-family: Arial, sans-serif; margin: 0; }
    nav { background:#343a40; padding:10px; display:flex; gap:20px; }
    nav a { color:#fff; text-decoration:none; font-weight:bold; }
    nav a:hover { text-decoration:underline; }

    .container { padding:16px; }
    .row { display:flex; gap:16px; align-items:flex-end; flex-wrap:wrap; }
    .card { background:#f8f9fa; border-radius:8px; padding:12px; margin-bottom:14px; }
    .card .input { font-size: 14px; }
    .card select.input { font-size: 12px; padding: 7px 12px; height: auto; }

    .card h3 { margin:4px 0 10px 0; font-size:16px; }

    label { font-size:12px; color:#333; display:block; margin-bottom:4px; }
    input[type="text"], input[type="number"], select {
      width:100%; padding:6px; box-sizing:border-box; border:1px solid #ccc; border-radius:6px;
    }

    .btnbar { display:flex; gap:8px; margin-top:0; flex-wrap:wrap; }
    button { padding:7px 12px; border-radius:6px; border:1px solid #888; background:#fff; cursor:pointer; }
    button.primary { background:#2b7cff; color:#fff; border-color:#2b7cff; }
    .disabled-btn { opacity:.5; pointer-events:none; }

    table { width:100%; border-collapse:collapse; }
    th, td { border-bottom:1px solid #e3e3e3; padding:6px 8px; font-size:13px; }
    th { text-align:left; background:#f5f6f7; }
    tr:hover { background:#f1f5ff; cursor:pointer; }

    .right { text-align:right; }
    .nowrap { white-space:nowrap; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .muted { color:#666; font-size:12px; }

    .sortable { cursor:pointer; user-select:none; }
    .sortable::after { content:' ⬍'; opacity:.4; }
    .sortable.sort-asc::after { content:' ▲'; opacity:.8; }
    .sortable.sort-desc::after { content:' ▼'; opacity:.8; }
    .nav-center { display: flex; justify-content: center; }

    /* 팝업 폭/높이 살짝 여유 */
    #sqlDialog {
        width: min(500px, 60vw);
    }

    /* SQL 텍스트 박스: 기본 높이만 늘리고, 세로 리사이즈 허용 */
    #sqlText {
        height: 380px;          /* 기존보다 조금 더 길게 */
        min-height: 380px;      /* 너무 작아지지 않게 */
        max-height: 50vh;       /* 화면 70%까지만 */
        resize: vertical;       /* 드래그로 높이 조절 가능 */
        overflow: auto;         /* 스크롤 */
    }

    /* params 칸: 공백/개행 유지 + 모노스페이스 + 가로 스크롤 */
    .params-pre
    {
        white-space: pre;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        font-size: 12px;
        line-height: 1.28;
        overflow-x: auto;
    }

  </style>
</head>
<body>

<nav class="nav-center">
  <a href="/">Alpha Cuda</a>
  <a href="/cuda">Simulations</a>
  <a href="/simul">New Simulation</a>
  <a href="/paramset">Param Sets</a>
</nav>

<div class="container">
  <h4 style="margin: 8px 0 10px 2px;">
      Alpha Cuda :: Simulation Result ( <span id="simulId">{{ simul_id }}</span> ) :
      <span id="simulName" style="margin-left:12px; color:#555;"></span>
  </h4>


  <!-- 상단 입력부: 카드 + 두 줄(row) 구성 -->
  <div class="card">
    <!-- 1행 -->
    <div class="row">
      <div style="min-width:140px;">
        <label>Max Rows</label>
        <select class="input" id="limit">
          <option value="100">100</option>
          <option value="200" selected>200</option>
          <option value="500">500</option>
          <option value="1000">1000</option>
        </select>
      </div>

      <div style="min-width:300px; flex:1;">
        <label>Filter (case / params)</label>
        <input class="input" type="text" id="filter" placeholder="">
      </div>

      <div style="min-width:120px;">
        <label>env_no</label>
        <input class="input" type="number" id="envNo" value="5">
      </div>

      <div>
        <label>&nbsp;</label>
        <div class="btnbar">
          <button id="reloadBtn" class="btn lg">Reload</button>
        </div>
      </div>

    </div>

    <!-- 2행: 범위/페이지 -->
    <div class="row" id="rangeBar">
      <div>
        <label>Win Rate (%)</label>
        <div style="display:flex; gap:6px;">
          <input class="input" type="number" id="winMin" style="width:90px;" >
          <span style="align-self:center;">~</span>
          <input class="input" type="number" id="winMax" style="width:90px;" >
        </div>
      </div>

      <div>
        <label>Profit</label>
        <div style="display:flex; gap:6px;">
          <input class="input" type="number" id="profitMin" style="width:110px;" >
          <span style="align-self:center;">~</span>
          <input class="input" type="number" id="profitMax" style="width:110px;" >
        </div>
      </div>

      <div>
        <label>Trade Count</label>
        <div style="display:flex; gap:6px;">
          <input class="input" type="number" id="tradesMin" style="width:110px;" >
          <span style="align-self:center;">~</span>
          <input class="input" type="number" id="tradesMax" style="width:110px;" >
        </div>
      </div>

      <div style="flex:1"></div>

      <div>
        <label>Page</label>
        <div style="display:flex; gap:6px; align-items:center;">
          <input class="input" type="number" id="page" value="1" style="width:80px;">
          <button class="input" id="prevPageBtn">Prev</button>
          <button class="input" id="nextPageBtn">Next</button>
        </div>
      </div>
    </div>
  </div>

  <div class="right" style="margin-left:auto">
    <div class="muted" id="status">Rows: 0</div>
  </div>
  <br>

  <!-- 리스트 카드 -->
  <div class="card">
    <table id="detailTable">
      <thead>
        <tr>
          <th>#</th>
          <th class="nowrap">gid</th>
          <th class="right nowrap sortable" data-sortkey="win_rate">win_rate (%)</th>
          <th class="right nowrap">wins</th>
          <th class="right nowrap">trades</th>
          <th class="right nowrap sortable" data-sortkey="profit">profit</th>
          <th>params</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<!-- SQL 팝업 -->
<dialog id="sqlDialog" style="max-width:900px; width:90%;">
  <div style="display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px;">
    <div style="display:flex; flex-direction:column; gap:6px;"><b>Generated SQL</b><div id="sqlMeta" style="font-size:12px; display:flex; flex-wrap:wrap; gap:6px;"></div></div>
    <div style="display:flex; gap:8px;">
      <button id="copySqlBtn">Copy</button>
      <button id="applySqlBtn">Apply</button>
      <button id="closeSqlBtn">Close</button>
    </div>
  </div>
  <textarea id="sqlText" style="width:100%; height:240px; font-family:ui-monospace,Consolas,Monaco,monospace; font-size:12px;"></textarea>
</dialog>

<script>
/* ====== 기존 스크립트는 그대로 두되, ID/구조만 위와 동일 ====== */

/* 정렬 상태 (기본: profit desc) */
let sortKey = 'profit';
let sortDir = 'desc';

function num(v, fallback = Number.NEGATIVE_INFINITY){
  const n = Number(v);
  return Number.isFinite(n) ? n : fallback;
}

/* URL state helpers (필요 시 사용) */
function saveStateToURL(){
  const qp = new URLSearchParams();
  qp.set('simul_id', String(simulId));
  qp.set('page_size', document.getElementById('limit').value);
  qp.set('page', document.getElementById('page').value);
  const wmin = document.getElementById('winMin').value.trim();
  const wmax = document.getElementById('winMax').value.trim();
  const pmin = document.getElementById('profitMin').value.trim();
  const pmax = document.getElementById('profitMax').value.trim();
  const tmin = document.getElementById('tradesMin').value.trim();
  const tmax = document.getElementById('tradesMax').value.trim();
  if (wmin) qp.set('win_min', wmin);
  if (wmax) qp.set('win_max', wmax);
  if (pmin) qp.set('profit_min', pmin);
  if (pmax) qp.set('profit_max', pmax);
  if (tmin) qp.set('trades_min', tmin);
  if (tmax) qp.set('trades_max', tmax);
  const f = document.getElementById('filter').value.trim();
  if (f) qp.set('filter', f);
  const envNo = document.getElementById('envNo').value.trim();
  if (envNo) qp.set('env_no', envNo);
  qp.set('sort', sortKey === 'win_rate' ? 'win_rate' : 'profit');
  qp.set('dir', sortDir === 'asc' ? 'asc' : 'desc');
  history.replaceState(null, '', '?' + qp.toString());
}

function getWinRate(r){
  if (r.win_rate != null) return Number(r.win_rate);
  const wins = Number(r.wins ?? r.win_cnt ?? 0);
  const trades = Number(r.trades ?? r.trade_cnt ?? 0);
  return trades > 0 ? (wins / trades * 100) : -1;
}
function getProfit(r){
  return num(r.total_profit ?? r.total_profit_ptr ?? r.profit_ptr, Number.NEGATIVE_INFINITY);
}
function updateHeaderSortUI(){
  document.querySelectorAll('th.sortable').forEach(th => {
    th.classList.remove('sort-asc','sort-desc');
    if (th.dataset.sortkey === sortKey){
      th.classList.add(sortDir === 'asc' ? 'sort-asc' : 'sort-desc');
    }
  });
}

/* simul_id 확보 */
let simulId = Number(document.getElementById('simulId').textContent);
if (!Number.isFinite(simulId) || simulId < 0) {
  const path = window.location.pathname.split('/').filter(Boolean);
  const fromPath = Number(path[path.length - 1]);
  if (Number.isFinite(fromPath) && fromPath > 0) simulId = fromPath;
}
if (!Number.isFinite(simulId) || simulId < 0) {
  const qp = new URLSearchParams(window.location.search);
  const fromQ = Number(qp.get('simul_id'));
  if (Number.isFinite(fromQ) && fromQ > 0) simulId = fromQ;
}

let simulName = null;
{
  const qp = new URLSearchParams(window.location.search);
  const fromQ = qp.get('simul_name');
  if (fromQ) simulName = decodeURIComponent(fromQ);
}


/* 평균기간 슬롯 매핑 */
const PERIODS = [3,5,7,10,15,20,25,30,35,40,45,50,55,60,70,80,120];
const AVG_TARGETS = new Set([
  "s1m1_entry_avg1","s1m1_entry_avg2",
  "s1m1_congest_avg1","s1m1_congest_avg2",
  "s1m1_congest2_avg1","s1m1_congest2_avg2",
  "s1m1_congest3_avg1","s1m1_congest3_avg2",
]);

function fmtNum(n){
  if (n === null || n === undefined) return null;
  if (Number.isInteger(n)) return String(n);
  const s = Number(n).toFixed(6);
  return s.replace(/\.0+$/,'').replace(/(\.\d*[1-9])0+$/,'$1');
}

/* param map */
function buildParamMap(item){
  const map = {};
  let foundAny = false;
  for (let i=1;i<=36;i++){
    const nk='p'+i+'_name', vk='p'+i+'_val';
    if (nk in item || vk in item){
      const name=item[nk], val=item[vk];
      if (name !== null && name !== undefined && String(name).trim() !== ''){
        const num = (val === null || val === undefined) ? null : Number(val);
        map[String(name)] = isNaN(num) ? null : num; foundAny = true;
      }
    }
  }
  if (!foundAny && item.param_summary){
    const pairs = String(item.param_summary).split(';');
    for (const p of pairs){
      const s = p.trim(); if (!s) continue;
      const idx = s.indexOf('='); if (idx === -1) continue;
      const k = s.slice(0, idx).trim();
      const v = s.slice(idx+1).trim();
      const num = Number(v);
      map[k] = isNaN(num) ? null : num;
    }
  }
  return map;
}

/* avg1/avg2 슬롯 → 실제 기간으로 변환 */
function applyAvgSlotConversion(map){
  for (const key of Object.keys(map)){
    if (!AVG_TARGETS.has(key)) continue;
    const val = map[key];
    if (val === null || Number.isNaN(Number(val))) continue;
    if (key.endsWith('_avg1')){
      const slot1 = Math.max(0, Math.min(PERIODS.length-1, Math.floor(Number(val))));
      map[key] = PERIODS[slot1];
      const key2 = key.replace('_avg1','_avg2');
      if (key2 in map && map[key2] !== null){
        const dist = Math.floor(Number(map[key2]));
        const idx2 = Math.max(0, Math.min(PERIODS.length-1, slot1 + dist));
        map[key2] = PERIODS[idx2];
      }
    }
  }
  return map;
}

/* UPDATE SQL 생성 */
function buildUpdateSQL(item, envNo){
  const raw = buildParamMap(item);
  const sets = [];
  applyAvgSlotConversion(raw);

  for (const [k, v] of Object.entries(raw)){
    if (k === 's1m1_entry_avg1' || k === 's1m1_entry_avg2') continue; // 별도 처리
    if (v === null || v === undefined) continue;
    const f = fmtNum(v); if (f === null) continue;
    sets.push(`${k}=${f}`);
  }

  const slot1_raw = raw['s1m1_entry_avg1'];
  const dist_raw  = raw['s1m1_entry_avg2'];
  const picked = new Set();
  if (slot1_raw !== null && slot1_raw !== undefined && !Number.isNaN(Number(slot1_raw))){
    const idx1 = Math.max(0, Math.min(PERIODS.length-1, Math.floor(Number(slot1_raw))));
    picked.add(PERIODS[idx1]);
    if (dist_raw !== null && dist_raw !== undefined && !Number.isNaN(Number(dist_raw))){
      const idx2 = Math.max(0, Math.min(PERIODS.length-1, idx1 + Math.floor(Number(dist_raw))));
      picked.add(PERIODS[idx2]);
    }
  }
  if (picked.size > 0){
    for (const p of PERIODS){
      const col = `is_s1m1_${'avg'}${p}`;
      const val = picked.has(p) ? 1 : 0;
      sets.push(`${col}=${val}`);
    }
  }
  if (sets.length === 0){
    return `-- No updatable parameters for env_no=${envNo}`;
  }
  return `UPDATE alpha.alpha_env SET ${sets.join(', ')} WHERE env_no=${envNo};`;
}

/* 데이터 로드 */
async function loadDetail(){
  const qp = new URLSearchParams();
  qp.set('simul_id', String(simulId));
  qp.set('page', document.getElementById('page').value || '1');
  qp.set('page_size', document.getElementById('limit').value || '200');

  const wmin = document.getElementById('winMin').value.trim();
  const wmax = document.getElementById('winMax').value.trim();
  const pmin = document.getElementById('profitMin').value.trim();
  const pmax = document.getElementById('profitMax').value.trim();
  const tmin = document.getElementById('tradesMin').value.trim();
  const tmax = document.getElementById('tradesMax').value.trim();
  if (wmin) qp.set('win_min', wmin);
  if (wmax) qp.set('win_max', wmax);
  if (pmin) qp.set('profit_min', pmin);
  if (pmax) qp.set('profit_max', pmax);
  if (tmin) qp.set('trades_min', tmin);
  if (tmax) qp.set('trades_max', tmax);

  qp.set('sort', sortKey === 'win_rate' ? 'win_rate' : 'profit');
  qp.set('dir', sortDir === 'asc' ? 'asc' : 'desc');

  const res = await fetch('/api/simul_detail?' + qp.toString());
  if (!res.ok) throw new Error(await res.text() || ('HTTP ' + res.status));
  return await res.json();
}

/* 필터 */
function matchFilter(r, token){
  if (!token) return true;
  const t = token.toLowerCase();
  return (
    String(r.case_id ?? r.gid ?? '').toLowerCase().includes(t) ||
    String(r.param_summary ?? '').toLowerCase().includes(t)
  );
}

/* 정렬 헤더 셋업 */
function setupSortHeaders(){
  document.querySelectorAll('#detailTable th.sortable').forEach(th => {
    th.addEventListener('click', () => {
      const key = th.dataset.sortkey;
      if (!key) return;
      if (key === sortKey) sortDir = (sortDir === 'desc') ? 'asc' : 'desc';
      else { sortKey = key; sortDir = 'desc'; }
      updateHeaderSortUI();
      const items = window.__detailCache || [];
      const filterVal = document.getElementById('filter').value.trim();
      renderTable(items, filterVal);
    });
  });
}

////////////////////////
// --- helpers ---------------------------------------------------------------



function _pad_right(s, n)
{
    return s + ' '.repeat(Math.max(0, n - s.length));
}

function adjust_sql_textarea_height()
{
    const ta = document.getElementById('sqlText');
    if (!ta) return;

    // 한 번 리셋 후 내용 높이만큼 확장 (최대 80vh, 최소 420px)
    ta.style.height = '0px';
    const h = Math.min(window.innerHeight * 0.8, ta.scrollHeight + 24);
    ta.style.height = Math.max(420, Math.floor(h)) + 'px';
}

function _kv_from_string(s)
{
    const t = String(s ?? '').trim().replace(/;$/, '');
    if (!t) return null;

    // "a=b" 우선, 그다음 "a:b" 도 허용
    let idx = t.indexOf('=');
    if (idx < 0) idx = t.indexOf(':');
    if (idx < 0) return { k: t, v: '' };

    const k = t.slice(0, idx).trim();
    const v = t.slice(idx + 1).trim();
    return { k, v };
}

function _drop_prefix_if_needed(k, drop_prefix)
{
    if (drop_prefix && k.startsWith(drop_prefix)) return k.slice(drop_prefix.length);
    return k;
}


/* any → ['key = val', ...]
 * - string: "a=1; b=2" or JSON("{...}"/"[...]") 모두 허용
 * - array : ["a=1","b=2"] 또는 [{name:'a',value:1}, {key:'b',val:2}] 등
 * - object: {a:1,b:2}
 */
function _normalize_to_pairs_any(raw, drop_prefix)
{
    const out = [];

    // 1) 문자열인 경우
    if (typeof raw === 'string')
    {
        const s = raw.trim();
        if (!s) return out;

        // JSON 문자열이면 파싱 시도
        if ((s.startsWith('{') && s.endsWith('}')) || (s.startsWith('[') && s.endsWith(']')))
        {
            try { return _normalize_to_pairs_any(JSON.parse(s), drop_prefix); }
            catch (_e) { /* 무시하고 아래 일반 파서로 */ }
        }

        // "a=1; b=2" → 분리
        s.split(';').forEach(seg =>
        {
            const kv = _kv_from_string(seg);
            if (kv && kv.k)
            {
                out.push(_drop_prefix_if_needed(kv.k, drop_prefix) + ' = ' + kv.v);
            }
        });
        return out;
    }

    // 2) 배열인 경우
    if (Array.isArray(raw))
    {
        for (const it of raw)
        {
            if (typeof it === 'string')
            {
                const kv = _kv_from_string(it);
                if (kv && kv.k)
                {
                    out.push(_drop_prefix_if_needed(kv.k, drop_prefix) + ' = ' + kv.v);
                }
                continue;
            }
            if (it && typeof it === 'object')
            {
                // 흔한 키 조합 추정: name/param/key + value/val/v
                const k = it.param_name ?? it.name ?? it.key ?? it.k;
                const v = it.param_value ?? it.value ?? it.val ?? it.v;

                if (k != null && v != null)
                {
                    out.push(_drop_prefix_if_needed(String(k), drop_prefix) + ' = ' + String(v));
                }
                else
                {
                    // 일반 객체라면 모든 키를 펼쳐서 추가
                    for (const kk of Object.keys(it))
                    {
                        out.push(_drop_prefix_if_needed(String(kk), drop_prefix) + ' = ' + String(it[kk]));
                    }
                }
                continue;
            }
            // 숫자/불리언 등은 문자열로
            out.push(String(it));
        }
        return out;
    }

    // 3) 일반 객체인 경우
    if (raw && typeof raw === 'object')
    {
        for (const k of Object.keys(raw))
        {
            out.push(_drop_prefix_if_needed(String(k), drop_prefix) + ' = ' + String(raw[k]));
        }
        return out;
    }

    // 4) 그 외(숫자/불리언 등)
    return [String(raw ?? '')];
}

function _normalize_pair(p)
{
    const idx = p.indexOf('=');
    if (idx > 0)
    {
        const k = p.slice(0, idx).trim();
        const v = p.slice(idx + 1).trim();
        return { key: k, pair: k + ' = ' + v };
    }
    return { key: p.trim(), pair: p.trim() };
}

function _normalize_pair(s, drop_prefix)
{
    if (!s) return '';
    const t = s.trim().replace(/;$/, '');
    if (!t) return '';
    const eq = t.indexOf('=');
    if (eq < 0) return t;

    let k = t.slice(0, eq).trim();
    const v = t.slice(eq + 1).trim();

    if (drop_prefix && k.startsWith(drop_prefix)) k = k.slice(drop_prefix.length);
    return k + ' = ' + v;
}

/*
 * params(any) → 3컬럼 정렬 여러 줄
 * opts: { cols: 3, drop_prefix: 's1m1_', col_width, min_w: 18, max_w: 40, sort_keys: true }
 */
function format_params_grid(raw_params, opts)
{
    const cols        = (opts && opts.cols) || 3;
    const drop_prefix = (opts && opts.drop_prefix) || '';
    const min_w       = (opts && opts.min_w) || 18;
    const max_w       = (opts && opts.max_w) || 40;
    const sort_keys   = (opts && opts.sort_keys) !== false;

    let pairs = _normalize_to_pairs_any(raw_params, drop_prefix)
                .filter(Boolean);

    // 보기 일정하게 정렬 (원치 않으면 sort_keys:false)
    if (sort_keys)
    {
        pairs.sort((a, b) => a.localeCompare(b));
    }

    if (pairs.length === 0) return '';

    const max_len = pairs.reduce((m, p) => Math.max(m, p.length), 0);
    const col_w   = Math.max(min_w, Math.min((opts && opts.col_width) || (max_len + 2), max_w));

    const lines = [];
    for (let i = 0; i < pairs.length; i += cols)
    {
        let line = '  ';
        for (let c = 0; c < cols; c++)
        {
            const it = pairs[i + c];
            if (!it) break;

            const last_in_row = (c === cols - 1) || (i + c === pairs.length - 1);
            line += last_in_row ? it : _pad_right(it, col_w);
            if (!last_in_row) line += '  ';
        }
        lines.push(line);
    }
    return lines.join('\n');
}





function _split_set_pairs(set_part)
{
    const out = [];
    let cur = '', depth = 0, in_q = false, qch = '';

    for (let i = 0; i < set_part.length; i++)
    {
        const ch = set_part[i];

        if (!in_q && (ch === '"' || ch === "'"))
        {
            in_q = true; qch = ch; cur += ch; continue;
        }
        if (in_q && ch === qch)
        {
            in_q = false; cur += ch; continue;
        }

        if (!in_q)
        {
            if (ch === '(') depth++;
            else if (ch === ')' && depth > 0) depth--;
        }

        if (!in_q && depth === 0 && ch === ',')
        {
            if (cur.trim()) out.push(cur.trim());
            cur = '';
            continue;
        }
        cur += ch;
    }
    if (cur.trim()) out.push(cur.trim());
    return out;
}

function _categorize_key(key)
{
    const k = String(key).toLowerCase();
    if (k.includes('congest2')) return 'congest2';
    if (k.includes('congest'))  return 'congest';
    return 'other';
}







// --- main: grouped two-column formatter ------------------------------------
function format_sql_for_popup_grouped(raw_sql, opts)
{
    const col_width  = Math.max(36, Math.min((opts && opts.col_width) || 44, 72));
    const group_order = (opts && opts.group_order) || ['other', 'congest', 'congest2'];
    const with_labels = !!(opts && opts.with_labels);   // 주석 라벨(옵션)

    if (typeof raw_sql !== 'string') return String(raw_sql ?? '');

    const m = raw_sql.replace(/\s+/g, ' ')
                     .match(/^UPDATE\s+(.+?)\s+SET\s+(.+?)\s+WHERE\s+(.+?);?$/i);
    if (!m) return raw_sql;

    const table      = m[1].trim();
    const set_part   = m[2].trim();
    const where_part = m[3].trim();

    // items: [{key, pair}]
    const items = _split_set_pairs(set_part).map(_normalize_pair);

    // 그룹핑
    const buckets = { other: [], congest: [], congest2: [] };
    for (const it of items) buckets[_categorize_key(it.key)].push(it);

    // 출력용 총합 배열(그룹 순서 반영)
    const ordered_groups = group_order.map(g => ({ name: g, items: buckets[g] || [] }));
    const total_real = ordered_groups.reduce((a, g) => a + g.items.length, 0);

    // 줄 빌드: 각 그룹은 **항상 새 줄에서 시작** (그룹 경계를 명확히)
    const lines = [];
    let global_idx = 0; // 실 항목의 전역 인덱스(콤마 판단용)

    for (let gi = 0; gi < ordered_groups.length; gi++)
    {
        const g = ordered_groups[gi];
        if (g.items.length === 0) continue;

        if (with_labels)
        {
            // SQL 주석 라벨(복붙 실행 가능)
            lines.push('  -- [' + g.name + ']');
        }

        for (let i = 0; i < g.items.length; )
        {
            // 왼쪽
            const left_obj = g.items[i];
            const is_last_left = (global_idx === total_real - 1);
            const left_pair = left_obj.pair + (is_last_left ? '' : ',');
            i += 1; global_idx += 1;

            // 오른쪽 (같은 그룹에서만 매칭해 그룹 경계가 항상 새 줄에 오도록)
            let right_pair = '';
            if (i < g.items.length)
            {
                const is_last_right = (global_idx === total_real - 1);
                right_pair = g.items[i].pair + (is_last_right ? '' : ',');
                i += 1; global_idx += 1;
            }

            lines.push('  ' + _pad_right(left_pair, col_width) + right_pair);
        }

        // 그룹 사이 가독성용 공백 줄 (마지막 그룹은 생략)
        if (with_labels && gi < ordered_groups.length - 1)
        {
            lines.push('');
        }
    }

    return 'UPDATE ' + table + '\nSET\n' + lines.join('\n') + '\nWHERE ' + where_part + ';';
}


////////////////////////////////////


// ---------- safe helpers (no name collision) ----------
function _fp_pad_right_v2(s, n)
{
    return s + ' '.repeat(Math.max(0, n - s.length));
}

function _fp_split_set_pairs_v2(set_part)
{
    const out = [];
    let cur = '', depth = 0, in_q = false, qch = '';

    for (let i = 0; i < set_part.length; i++)
    {
        const ch = set_part[i];

        if (!in_q && (ch === '"' || ch === "'"))
        {
            in_q = true; qch = ch; cur += ch; continue;
        }
        if (in_q && ch === qch)
        {
            in_q = false; cur += ch; continue;
        }

        if (!in_q)
        {
            if (ch === '(') depth++;
            else if (ch === ')' && depth > 0) depth--;
        }

        if (!in_q && depth === 0 && ch === ',')
        {
            if (cur.trim()) out.push(cur.trim());
            cur = '';
            continue;
        }
        cur += ch;
    }
    if (cur.trim()) out.push(cur.trim());
    return out;
}

function _fp_to_kv_obj_v2(p)
{
    // 문자열 "k=v" → { key:'k', pair:'k = v' }
    if (typeof p === 'string')
    {
        const idx = p.indexOf('=');
        if (idx > 0)
        {
            const k = p.slice(0, idx).trim();
            const v = p.slice(idx + 1).trim();
            return { key: k, pair: k + ' = ' + v };
        }
        return { key: p.trim(), pair: p.trim() };
    }
    // 이미 {key, pair} 형태라면 그대로 사용
    if (p && typeof p === 'object' && 'key' in p && 'pair' in p)
    {
        return p;
    }
    // 그 외는 방어적으로 문자열화
    const s = String(p ?? '');
    return { key: s, pair: s };
}

function _fp_group_of_v2(key)
{
    const k = String(key || '').toLowerCase();
    if (k.includes('congest2')) return 'congest2';
    if (k.includes('congest'))  return 'congest';
    return 'other';
}

// ---------- main: grouped pretty-print (safe v2) ----------
function format_sql_for_popup_grouped_v2(raw_sql, opts)
{
    const col_width   = Math.max(36, Math.min((opts && opts.col_width) || 44, 60));
    const group_order = (opts && opts.group_order) || ['other', 'congest', 'congest2'];
    const with_labels = !!(opts && opts.with_labels);

    if (typeof raw_sql !== 'string') return String(raw_sql ?? '');

    // 멀티라인 허용 파서
    const m = raw_sql.match(/^UPDATE\s+(.+?)\s+SET\s+([\s\S]+?)\s+WHERE\s+(.+?);?$/i);
    if (!m) return raw_sql;

    const table      = m[1].trim();
    const set_part   = m[2].trim();
    const where_part = m[3].trim();

    // 문자열 목록 → 안전한 {key, pair} 객체 목록
    const items = _fp_split_set_pairs_v2(set_part).map(_fp_to_kv_obj_v2);

    // 그룹핑
    const buckets = { other: [], congest: [], congest2: [] };
    for (const it of items) buckets[_fp_group_of_v2(it.key)].push(it);

    const groups = group_order.map(g => ({ name: g, items: buckets[g] || [] }));
    const total  = groups.reduce((a, g) => a + g.items.length, 0);

    const lines = [];
    let idx = 0;

    for (let gi = 0; gi < groups.length; gi++)
    {
        const g = groups[gi];
        if (g.items.length === 0) continue;

        if (with_labels) lines.push('  -- [' + g.name + ']');

        for (let i = 0; i < g.items.length; )
        {
            // left
            const left = g.items[i];
            const is_last_left = (idx === total - 1);
            const left_pair = left.pair + (is_last_left ? '' : ',');
            i += 1; idx += 1;

            // right (같은 그룹에서만 페어링)
            let right_pair = '';
            if (i < g.items.length)
            {
                const is_last_right = (idx === total - 1);
                right_pair = g.items[i].pair + (is_last_right ? '' : ',');
                i += 1; idx += 1;
            }

            lines.push('  ' + _fp_pad_right_v2(left_pair, col_width) + right_pair);
        }

        if (with_labels && gi < groups.length - 1) lines.push('');
    }

    return 'UPDATE ' + table + '\nSET\n' + lines.join('\n') + '\nWHERE ' + where_part + ';';
}







/* 테이블 렌더 */
function renderTable(items, token){
  const tbody = document.querySelector('#detailTable tbody');
  tbody.innerHTML = '';

  const filtered = items.filter(r => matchFilter(r, token));
  filtered.sort((a, b) => {
    const va = (sortKey === 'profit') ? getProfit(a) : getWinRate(a);
    const vb = (sortKey === 'profit') ? getProfit(b) : getWinRate(b);
    if (va !== vb) return (sortDir === 'desc') ? (vb - va) : (va - vb);
    const pa = getProfit(a), pb = getProfit(b);
    const wa = getWinRate(a), wb = getWinRate(b);
    if (sortKey === 'profit'){ if (wb !== wa) return wb - wa; }
    else { if (pb !== pa) return pb - pa; }
    return (a.gid ?? a.case_id ?? 0) - (b.gid ?? b.case_id ?? 0);
  });

  let rank = 0;
  for (const r of filtered){
    rank += 1;
    const tr = document.createElement('tr');
    tr.title = '클릭하면 UPDATE SQL을 생성합니다';

    tr.addEventListener('click', async () => {
      __lastSelectedDetailRow = r;
      __lastCombinedPayload = null; // reset

      const envNo = parseInt(document.getElementById('envNo').value, 10) || 0;
      const gid   = (r.gid ?? r.case_id ?? null);
      const dlg = document.getElementById('sqlDialog');
      const ta  = document.getElementById('sqlText');

      try {
        if (!gid) throw new Error('gid not found in row');
        // Ask server to build combined SQL (handles both main & sub cases)
        const qp = new URLSearchParams();
        qp.set('sub_simul_id', String(simulId));
        qp.set('gid', String(gid));
        qp.set('env_no', String(envNo));
        const res = await fetch('/api/combined_env_update?' + qp.toString());
        const js  = await res.json();
        if (!res.ok || !js.ok) {
          throw new Error(js && js.error ? js.error : ('HTTP ' + res.status));
        }
        ta.value = js.sql || '-- No SQL returned';
        __lastCombinedPayload = { env_no: envNo, updates: js.updates || {} };

        // Meta banner
        const meta = document.getElementById('sqlMeta');
        if (meta){
          const mt = js.simul_type;
          const msid = js.main_simul_id ?? null;
          const mgid = js.main_gid ?? js.main_simul_gid ?? null;
          const ssid = js.sub_simul_id ?? simulId;
          const sgid = js.sub_gid ?? gid;
          const badge = (k,v)=>`<span style="padding:2px 6px;border:1px solid #999;border-radius:999px;">${k}: <b>${v}</b></span>`;
          const parts = [];
          parts.push(badge('simul_type', mt));
          parts.push(badge('main_simul_id', msid ?? '-'));
          parts.push(badge('main_gid', mgid ?? '-'));
          parts.push(badge('sub_simul_id', ssid ?? '-'));
          parts.push(badge('sub_gid', sgid ?? '-'));
          meta.innerHTML = parts.join(' ');
        }
      } catch (e) {
        // Fallback: local single-row build (main-only)
        const sql = buildUpdateSQL(r, envNo);
        ta.value = sql;
        __lastCombinedPayload = null;
      }

      ta.value = format_sql_for_popup_grouped_v2(ta.value, {
          col_width: 36,                 // 팝업 폭에 맞춰 40~48 권장
          group_order: ['congest', 'congest2', 'other'], // congest 묶음을 앞쪽으로
          with_labels: true             // true로 하면 그룹 라벨 주석 라인 추가
      });

      if (typeof dlg.showModal === 'function') dlg.showModal();
      else dlg.setAttribute('open','');

      adjust_sql_textarea_height();
    });

    const td_rank = document.createElement('td'); td_rank.textContent = rank;
    const td_case = document.createElement('td'); td_case.textContent = r.case_id ?? r.gid ?? ''; td_case.className = 'mono';

    const td_wr = document.createElement('td');
    td_wr.textContent = (r.win_rate != null) ? Number(r.win_rate).toFixed(2)
                                             : (getWinRate(r) >= 0 ? getWinRate(r).toFixed(2) : '');
    td_wr.className = 'right';

    const td_wc = document.createElement('td'); td_wc.textContent = r.wins ?? r.win_cnt ?? ''; td_wc.className = 'right';
    const td_tc = document.createElement('td'); td_tc.textContent = r.trades ?? r.trade_cnt ?? ''; td_tc.className = 'right';

    const profit = (r.total_profit ?? r.total_profit_ptr ?? r.profit_ptr ?? '');


    // 기존
    // const td_pf = document.createElement('td'); td_pf.textContent = Number(profit || 0).toFixed(2); td_pf.className = …
    // const td_par = document.createElement('td'); td_par.textContent = r.param_summary ?? '';

    // 교체
    // profit 셀 (기존 유지)
    const td_pf = document.createElement('td');
    td_pf.textContent = Number(profit || 0).toFixed(2);
    td_pf.className = 'right';

    // params 셀 (3컬럼 포맷)
    const td_par = document.createElement('td');
    const pre = document.createElement('pre');
    pre.className = 'params-pre';
    pre.textContent = format_params_grid(r.param_summary ?? '', {
        cols: 4,
        drop_prefix: 's1m1_',   // 접두사 제거 안 하려면 '' 로
        min_w: 20,
        max_w: 26
    });
    td_par.appendChild(pre);

    // append
    tr.appendChild(td_rank);
    tr.appendChild(td_case);
    tr.appendChild(td_wr);
    tr.appendChild(td_wc);
    tr.appendChild(td_tc);
    tr.appendChild(td_pf);
    tr.appendChild(td_par);
    tbody.appendChild(tr);
  }
  document.getElementById('status').textContent = 'Rows: ' + filtered.length;
}




/* 로드 & 페이저 */
async function reload(){
  const status = document.getElementById('status');
  status.textContent = 'Loading...';
  try{
    saveStateToURL();
    const data = await loadDetail();
    const items = data.items || [];
    window.__detailCache = items;
    window.__total = data.total || 0;
    window.__pages = data.pages || 0;
    renderTable(items, document.getElementById('filter').value.trim());

    const page = Number(document.getElementById('page').value || '1');
    //status.textContent = `Page ${page}/${window.__pages || 0} • Rows on page: ${items.length} • Total: ${window.__total}`;
    status.textContent = `Page ${page}/${window.__pages || 0} • Total: ${window.__total}`;

    document.getElementById('prevPageBtn').classList.toggle('disabled-btn', page <= 1);
    document.getElementById('nextPageBtn').classList.toggle('disabled-btn', window.__pages && page >= window.__pages);

  }catch(err){
    status.textContent = 'Error: ' + err.message;
    console.error(err);
  }
}

let __lastSelectedDetailRow = null;
let __lastCombinedPayload = null;

/* 정렬 헤더 초기화 */
setupSortHeaders();

/* APPLY 버튼 */

document.getElementById('applySqlBtn').addEventListener('click', async () => {
  try{
    const envNo = parseInt(document.getElementById('envNo').value, 10) || 0;
    if (!envNo) { alert('Invalid env_no'); return; }
    if (!confirm(`Apply updates to alpha.alpha_env (env_no=${envNo}) ?`)) return;

    // Prefer server-combined payload when available
    let payload = __lastCombinedPayload;
    if (!payload) {
      const item = __lastSelectedDetailRow;
      if (!item) { alert('No row selected.'); return; }

      // Fallback to local single row updates
      const raw = buildParamMap(item);
      applyAvgSlotConversion(raw);
      const updates = {};
      for (const [k, v] of Object.entries(raw)){
        if (k === 's1m1_entry_avg1' || k === 's1m1_entry_avg2') continue;
        if (v === null || v === undefined) continue;
        const num = Number(v);
        if (!Number.isNaN(num)) updates[k] = num;
      }
      const slot1_raw = raw['s1m1_entry_avg1'];
      const dist_raw  = raw['s1m1_entry_avg2'];
      const picked = new Set();
      if (slot1_raw !== null && slot1_raw !== undefined && !Number.isNaN(Number(slot1_raw))){
        const idx1 = Math.max(0, Math.min(PERIODS.length-1, Math.floor(Number(slot1_raw))));
        picked.add(PERIODS[idx1]);
        if (dist_raw !== null && dist_raw !== undefined && !Number.isNaN(Number(dist_raw))){
          const idx2 = Math.max(0, Math.min(PERIODS.length-1, idx1 + Math.floor(Number(dist_raw))));
          picked.add(PERIODS[idx2]);
        }
      }
      if (picked.size > 0){
        for (const p of PERIODS) updates[`is_s1m1_avg${p}`] = picked.has(p) ? 1 : 0;
      }
      payload = { env_no: envNo, updates };
    }

    const res = await fetch('/api/apply_env_update', {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const js = await res.json().catch(() => ({}));
    if (!res.ok || !js.ok){
      const msg = js && js.error ? js.error : `HTTP ${res.status}`;
      alert('Apply failed: ' + msg + '\n(If disabled, set ALPHA_ENABLE_APPLY=1 and restart)');
      return;
    }
    alert(`Apply OK (updated ${js.rowcount} row, cols=${(js.updated_columns||[]).length})`);
  }catch(e){
    alert('Apply error: ' + (e.message || e));
  }
});

if (simulName) {
  document.getElementById('simulName').textContent = `${simulName}`;
}


/* 페이저 & 입력 이벤트 */
document.getElementById('prevPageBtn').addEventListener('click', () => {
  const pageEl = document.getElementById('page');
  let p = parseInt(pageEl.value||'1',10);
  if (p > 1){ pageEl.value = String(p-1); reload(); }
});
document.getElementById('nextPageBtn').addEventListener('click', () => {
  const pageEl = document.getElementById('page');
  let p = parseInt(pageEl.value||'1',10);
  const maxp = window.__pages || (p+1);
  if (p < maxp){ pageEl.value = String(p+1); reload(); }
});
['page','limit','winMin','winMax','profitMin','profitMax','tradesMin','tradesMax'].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('change', () => reload());
  el.addEventListener('keydown', (e) => { if (e.key === 'Enter') reload(); });
});

document.getElementById('reloadBtn').addEventListener('click', reload);
document.getElementById('filter').addEventListener('input', () => {
  const items = window.__detailCache || [];
  renderTable(items, document.getElementById('filter').value.trim());
});
document.getElementById('copySqlBtn').addEventListener('click', async () => {
  const ta = document.getElementById('sqlText'); ta.select();
  try { await navigator.clipboard.writeText(ta.value); } catch(e){}
});
document.getElementById('closeSqlBtn').addEventListener('click', () => {
  const dlg = document.getElementById('sqlDialog');
  if (typeof dlg.close === 'function') dlg.close(); else dlg.removeAttribute('open');
});


/* 초기 로드 */
(async () => {
  try {
    await reload();
    updateHeaderSortUI();
  } catch (e) {
    document.getElementById('status').textContent = 'Error: ' + e.message;
  }
})();
</script>
</body>
</html>

